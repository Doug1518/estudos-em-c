#include <stdio.h>
#include <stdlib.h>
#include <locale.h>
#include <math.h>
#include <time.h>
#include <string.h>// para usar o strlen
#include <ctype.h>
// #include "pilha.h"

typedef struct no{
    float valor;
    struct no *proximo;
}No;

No* empilhar(No *pilha, float num){
    No *novo = malloc(sizeof(No));

    if(novo){
        novo->valor = num;
        novo->proximo = pilha;
        return novo;
    }
    else
        printf("\tErro ao alocar memoria!\n");
    return NULL;
}

No* desempilhar(No **pilha){
    No *remover = NULL;

    if(*pilha){
        remover = *pilha;
        *pilha = remover->proximo;
    }
    else
        printf("\tPilha vazia\n");
    return remover;
}

float operacao(float a, float b, char x){
    switch(x){
    case '+':
        return a + b;
        break;
    case '-':
        return a - b;
        break;
    case '/':
        return a / b;
        break;
    case '*':
        return a * b;
        break;
    default:
        return 0.0;
    }
}

float resolver_expressao(char x[]){
    char *pt;
    float num;
    No *n1, *n2, *pilha = NULL;

    pt = strtok(x, " ");
    while(pt){
        if(pt[0] == '+' || pt[0] == '-' || pt[0] == '/' || pt[0] == '*'){
            n1 = desempilhar(&pilha);
            n2 = desempilhar(&pilha);
            num = operacao(n2->valor, n1->valor, pt[0]);
            pilha = empilhar(pilha, num);
            free(n1);
            free(n2);
        }
        else{
            num = strtol(pt, NULL, 10);
            pilha = empilhar(pilha, num);
        }
        pt = strtok(NULL, " ");
    }
    n1 = desempilhar(&pilha);
    num = n1->valor; 
    free(n1);
    return num;
}

int main(){
    char exp[50] = {"5 3 2 4 6 7 1 + * + * + *"};

    printf("Resultado de %s:\t", exp);
    printf("%f\n", resolver_expressao(exp));
}


/*      Aula 233

        4) Notação pós-fixa (polonesa reversa) (calculadoras HP)
        Infixa                      Pós-fixa
        (51+13*12)                  51 13 12 * +                R = 207
        (5*(3+2)/4-6)               5 3 2 + * 4 / 6 -           R = 0,25
        (5+3+2*4-6*7*1)             5 3 + 2 4 * + 6 7 * 1 * -   R = -26
        (5*(3+(2*(4+(6*(7+1))))))   5 3 2 4 6 7 1 + * + * + *   R = 535

        


typedef struct no{
    float valor;
    struct no *proximo;
}No;

No* empilhar(No *pilha, float num){
    No *novo = malloc(sizeof(No));

    if(novo){
        novo->valor = num;
        novo->proximo = pilha;
        return novo;
    }
    else
        printf("\tErro ao alocar memoria!\n");
    return NULL;
}

No* desempilhar(No **pilha){
    No *remover = NULL;

    if(*pilha){
        remover = *pilha;
        *pilha = remover->proximo;
    }
    else
        printf("\tPilha vazia\n");
    return remover;
}

float operacao(float a, float b, char x){
    switch(x){
    case '+':
        return a + b;
        break;
    case '-':
        return a - b;
        break;
    case '/':
        return a / b;
        break;
    case '*':
        return a * b;
        break;
    default:
        return 0.0;
    }
}

float resolver_expressao(char x[]){
    char *pt;
    float num;
    No *n1, *n2, *pilha = NULL;

    pt = strtok(x, " ");
    while(pt){
        if(pt[0] == '+' || pt[0] == '-' || pt[0] == '/' || pt[0] == '*'){
            n1 = desempilhar(&pilha);
            n2 = desempilhar(&pilha);
            num = operacao(n2->valor, n1->valor, pt[0]);
            pilha = empilhar(pilha, num);
            free(n1);
            free(n2);
        }
        else{
            num = strtol(pt, NULL, 10);
            pilha = empilhar(pilha, num);
        }
        pt = strtok(NULL, " ");
    }
    n1 = desempilhar(&pilha);
    num = n1->valor;
    free(n1);
    return num;
}

int main(){
    char exp[50] = {"5 3 2 4 6 7 1 + * + * + *"};

    printf("Resultado de %s:\t", exp);
    printf("%f\n", resolver_expressao(exp));
}
*/



/*
    =

    3) Escreva um algoritmo para inverter a ordem das letras de cada palavra de uma string, preservando a ordem das palavras.
       Por exemplo, dado o texto: ABRA A PORTA MARIQUINHA
       A saída deve ser: ARBA A ATROP AHNIUQIRAM


typedef struct no{
    char caracter;
    struct no *proximo;
}No;

No* empilhar(No *pilha, char valor){
    No *novo = malloc(sizeof(No));

    if(novo){
        novo->caracter = valor;
        novo->proximo = pilha;
        return novo;
    }
    else
        printf("\tErro ao alocar memoria!\n");
    return NULL;
}

No* desempilhar(No **pilha){
    No *remover = NULL;

    if(*pilha){
        remover = *pilha;
        *pilha = remover->proximo;
    }
    else
        printf("\tPilha vazia\n");
    return remover;
}

void inverter_palavras(char x[]){
    int i = 0;
    No *remover, *pilha = NULL;

    while(x[i] != '\0'){
        if(x[i] != ' ')
            pilha = empilhar(pilha, x[i]);
        else {
            while(pilha){
                remover = desempilhar(&pilha);
                printf("%c", remover->caracter);
                free(remover);
            }
            printf(" ");
        }
        i++;
    }
    while(pilha){
        remover = desempilhar(&pilha);
        printf("%c", remover->caracter);
        free(remover);
    }
    printf("\n");
}

int main(){
    char texto[50] = {"EU NAO ABRO NAO!"};

    inverter_palavras(texto);
}
*/

/*
            Aula 231: Como descobrir se uma expressão matemática está mal formada?

            Código escrito por Wagner Gaspar
            Julho de 2021


typedef struct no{
    char caracter;
    struct no *proximo;
}No;

No* empilhar(No *pilha, char valor){
    No *novo = malloc(sizeof(No));

    if(novo){
        novo->caracter = valor;
        novo->proximo = pilha;
        return novo;
    }
    else
        printf("\tErro ao alocar memoria!\n");
    return NULL;
}

No* desempilhar(No **pilha){
    No *remover = NULL;

    if(*pilha){
        remover = *pilha;
        *pilha = remover->proximo;
    }
    else
        printf("\tPilha vazia\n");
    return remover;
}

void imprimir(No *pilha){
    printf("\n\tPILHA\n");
    while(pilha){
        printf("\t%c\n", pilha->caracter);
        pilha = pilha->proximo;
    }
    printf("\tFIM PILHA\n\n");
}

int forma_par(char f, char d){
    switch(f){
    case ')':
        if(d == '(')
            return 1; // bem formada
        else
            return 0; // mal formada
        break;
    case ']':
        if(d == '[')
            return 1; // bem formada
        else
            return 0; // mal formada
        break;
    case '}':
        if(d == '{')
            return 1; // bem formada
        else
            return 0; // mal formada
        break;
    }
}

int identifica_formacao(char x[]){
    int i = 0;
    No *remover, *pilha = NULL;

    while(x[i] != '\0'){
        if(x[i] == '[' || x[i] == '(' || x[i] == '{'){
            pilha = empilhar(pilha, x[i]);
            imprimir(pilha);
        }
        else if(x[i] == ']' || x[i] == ')' || x[i] == '}'){
            remover = desempilhar(&pilha);
            if(forma_par(x[i], remover->caracter) == 0){
                printf("\tEXPRESSAO MAL FORMADA!\n");
                return 1; // expressao está mal formada
            }
            free(remover);
        }
        i++;
    }
    imprimir(pilha);
    if(pilha){
        printf("\tExpressao mal formada!\n");
        return 1;
    }
    else{
        printf("\tEXPRESSAO BEM FORMADA!\n");
        return 0;
    }
}

int main(){
    char exp[50];

    printf("\tDigite um expressao: ");
    scanf("%49[^\n]", exp);
    printf("\nExpressao: %s\nRetorno: %d\n", exp, identifica_formacao(exp));
}


*/


/* Aula 230: como criar arquivos de cabeçalho .h foi criado o arquivo pilha.c e piha. h


// funÃ§Ã£o para calcular o fatorial por meio de uma pilha
int fatorial(int num){
    No *remover, *pilha = NULL;

    while(num > 1){
        pilha = empilhar(pilha, num);
        num--;
    }

    imprimir(pilha);

    while(pilha){
        remover = desempilhar(&pilha);
        num = num * remover->valor;
        free(remover);
    }
    return num;
}



int main(){
    int valor;

    printf("Digite um valor maior que zero para o fatorial: ");
    scanf("%d", &valor);
    printf("\tFatorial de %d: %d\n", valor, fatorial(valor));


}

*/ 


/* Duvidas tiradas do chat gpt(desconsiderar erros de portuguÃªs) por conta da aula 229

so para ver se entendi o desempilhar ele recebe um ponteiro de ponteiro como argumento pois ele vai ter que "guardar o endereÃ§o do topo" para quando o elemento do topo foi removido o valor que aponta o ponteiro proximo sera passado para o topo

Isso mesmo! Vou detalhar a lÃ³gica para deixar ainda mais claro:

Por que usar um ponteiro de ponteiro (No **pilha):

A funÃ§Ã£o desempilhar recebe um ponteiro de ponteiro porque precisamos atualizar diretamente o ponteiro do topo da pilha dentro da funÃ§Ã£o. Quando a funÃ§Ã£o atualiza o topo para o prÃ³ximo elemento, essa mudanÃ§a precisa ser refletida fora do escopo da funÃ§Ã£o.
O ponteiro de ponteiro permite que a funÃ§Ã£o desempilhar acesse e modifique o endereÃ§o de memÃ³ria onde o ponteiro original do topo (no main ou outra funÃ§Ã£o) estÃ¡ guardado.
Como desempilhar funciona passo a passo:

Linha 1: Declara o ponteiro remover para guardar temporariamente o nÃ³ que serÃ¡ removido (o topo atual da pilha).
Linha 2-3: Verifica se a pilha nÃ£o estÃ¡ vazia (if (*pilha)).
Se nÃ£o estÃ¡ vazia:
Linha 3: A variÃ¡vel remover Ã© configurada para apontar para o nÃ³ do topo atual (armazenado em *pilha).
Linha 4: Atualiza *pilha para o prÃ³ximo nÃ³, ou seja, *pilha = remover->proximo;. Isso significa que agora o topo aponta para o segundo elemento da pilha (ou NULL se nÃ£o houver outros nÃ³s).
Linha 6: Se a pilha estiver vazia, imprime "Pilha vazia!".
Linha 7: Retorna o ponteiro remover, para que possamos liberar a memÃ³ria do nÃ³ removido ou usar o valor armazenado, se necessÃ¡rio.
Em resumo:

A funÃ§Ã£o desempilhar pega o nÃ³ do topo, faz o ponteiro *pilha (o novo topo) apontar para o prÃ³ximo nÃ³ e retorna o nÃ³ antigo. Isso permite acessar o valor e liberar a memÃ³ria ocupada pelo nÃ³ antigo, mantendo a pilha consistente.



Codigo com alteraÃ§Ãµes do chat gpt para ficar mais intuitivo

Aqui estÃ¡ uma versÃ£o mais intuitiva e bem comentada do seu cÃ³digo para cÃ¡lculo de fatorial usando pilha, com nomes de variÃ¡veis e funÃ§Ãµes que deixam o cÃ³digo mais claro:


#include <stdio.h>
#include <stdlib.h>

// Define uma estrutura para representar um nÃ³ da pilha
typedef struct Nodo {
    int valor; // Armazena o valor inteiro
    struct Nodo *proximo; // Aponta para o prÃ³ximo nÃ³ na pilha
} Nodo;

// FunÃ§Ã£o para adicionar (empilhar) um novo valor no topo da pilha
Nodo* adicionar_no_topo(Nodo *topo, int numero) {
    Nodo *novo_nodo = malloc(sizeof(Nodo)); // Aloca espaÃ§o para um novo nÃ³

    if (novo_nodo) { // Verifica se a alocaÃ§Ã£o de memÃ³ria foi bem-sucedida
        novo_nodo->valor = numero; // Define o valor do novo nÃ³
        novo_nodo->proximo = topo; // Faz o novo nÃ³ apontar para o antigo topo
        return novo_nodo; // Retorna o novo nÃ³ como o topo da pilha
    } else {
        printf("Erro ao alocar memÃ³ria!\n");
        return NULL;
    }
}

// FunÃ§Ã£o para remover (desempilhar) o valor do topo da pilha
Nodo* remover_do_topo(Nodo **topo) {
    Nodo *nodo_a_remover = NULL;

    if (*topo) { // Verifica se a pilha nÃ£o estÃ¡ vazia
        nodo_a_remover = *topo; // Armazena o nÃ³ que serÃ¡ removido
        *topo = nodo_a_remover->proximo; // Atualiza o topo para o prÃ³ximo nÃ³
    } else {
        printf("Pilha vazia!\n");
    }
    return nodo_a_remover; // Retorna o nÃ³ removido (para liberar a memÃ³ria)
}

// FunÃ§Ã£o para imprimir todos os valores na pilha
void mostrar_pilha(Nodo *topo) {
    printf("\n\tPILHA ATUAL:\n");
    while (topo) {
        printf("\t%d\n", topo->valor);
        topo = topo->proximo; // Move para o prÃ³ximo nÃ³
    }
    printf("\n");
}

// FunÃ§Ã£o para calcular o fatorial de um nÃºmero usando pilha
int calcular_fatorial(int numero) {
    Nodo *topo = NULL;
    Nodo *nodo_a_remover;

    // Empilha cada nÃºmero atÃ© 1
    while (numero > 1) {
        topo = adicionar_no_topo(topo, numero);
        numero--;
    }

    mostrar_pilha(topo); // Mostra a pilha preenchida

    // Desempilha e calcula o fatorial
    while (topo) {
        nodo_a_remover = remover_do_topo(&topo);
        numero = numero * nodo_a_remover->valor;
        free(nodo_a_remover); // Libera a memÃ³ria do nÃ³ removido
    }
    return numero;
}

int main() {
    int valor;

    printf("Digite um nÃºmero maior que zero para o fatorial: ");
    scanf("%d", &valor);
    printf("\tFatorial de %d: %d\n", valor, calcular_fatorial(valor));

    return 0;
}

ExplicaÃ§Ã£o das AlteraÃ§Ãµes:
RenomeaÃ§Ã£o das VariÃ¡veis e FunÃ§Ãµes:

No foi renomeado para Nodo e empilhar para adicionar_no_topo, deixando claro que estamos adicionando ao topo da pilha.
desempilhar virou remover_do_topo, facilitando o entendimento de que estamos retirando o valor do topo.
ComentÃ¡rios Descritivos:

ExplicaÃ§Ãµes linha a linha ajudam a entender o que cada parte do cÃ³digo estÃ¡ fazendo e por que certas decisÃµes foram tomadas.
Clareza nos Nomes das FunÃ§Ãµes e ParÃ¢metros:

mostrar_pilha indica claramente a intenÃ§Ã£o da funÃ§Ã£o, que Ã© exibir o conteÃºdo da pilha.
Essas mudanÃ§as melhoram a legibilidade do cÃ³digo e tornam mais intuitivo o processo de empilhar, desempilhar e calcular o fatorial usando a pilha dinÃ¢mica.



no caso da funÃ§Ã£o empilhar quando na primeira etapa qunado Ã© insetido o primeiro valor  o topo fica apontando para esse valor e o ponteiro proximo fica nulo

O ChatGPT disse:
ChatGPT
MemÃ³ria atualizada
Sim, seu entendimento estÃ¡ correto. Quando a funÃ§Ã£o empilhar Ã© chamada pela primeira vez e um valor Ã© inserido, o topo (representado pela variÃ¡vel pilha ao chamar empilhar) aponta para o novo nÃ³ criado. Esse novo nÃ³, por sua vez, terÃ¡ seu ponteiro proximo apontando para NULL, indicando que ele Ã© o Ãºltimo elemento da pilha (ou o Ãºnico, no caso da primeira inserÃ§Ã£o).

Quando mais elementos sÃ£o adicionados, o novo nÃ³ inserido sempre se torna o novo topo da pilha. O campo proximo desse novo nÃ³ aponta para o antigo topo, formando uma cadeia onde cada nÃ³ aponta para o prÃ³ximo na pilha, e o Ãºltimo sempre aponta para NULL.

Essa estrutura permite que a pilha seja acessada de forma LIFO (Last In, First Out), ou seja, o Ãºltimo elemento inserido Ã© o primeiro a ser removido.

Aqui estÃ¡ uma representaÃ§Ã£o do que acontece:

Primeiro elemento inserido:

topo â [valor=1, proximo=NULL]
Segundo elemento inserido:

topo â [valor=2, proximo] â [valor=1, proximo=NULL]
E assim sucessivamente, com o topo sempre apontando para o elemento mais recente, e cada nÃ³ apontando para o prÃ³ximo atÃ© o final da pilha, onde o Ãºltimo proximo aponta para NULL.




*/

/*
            Aula 229: Como simular a recursÃ£o do fatorial com uma pilha?

            CÃ³digo escrito por Wagner Gaspar
            Julho de 2021


typedef struct no{
    int valor;
    struct no *proximo;
}No;

No* empilhar(No *pilha, int num){
    No *novo = malloc(sizeof(No));

    if(novo){
        novo->valor = num;
        novo->proximo = pilha;
        return novo;
    }
    else
        printf("Erro ao alocar memoria!\n");
    return NULL;
}

No* desempilhar(No **pilha){
    No *remover = NULL;

    if(*pilha){
        remover = *pilha;
        *pilha = remover->proximo;
    }
    else
        printf("Pilha vazia!\n");
    return remover;
}

void imprimir(No *pilha){
    printf("\n\tPILHA\n");
    while(pilha){
        printf("\t%d\n", pilha->valor);
        pilha = pilha->proximo;
    }
    printf("\n");
}

// funÃ§Ã£o para calcular o fatorial por meio de uma pilha
int fatorial(int num){
    No *remover, *pilha = NULL;

    while(num > 1){
        pilha = empilhar(pilha, num);
        num--;
    }

    imprimir(pilha);

    while(pilha){
        remover = desempilhar(&pilha);
        num = num * remover->valor;
        free(remover);
    }
    return num;
}

int main(){
    int valor;

    printf("Digite um valor maior que zero para o fatorial: ");
    scanf("%d", &valor);
    printf("\tFatorial de %d: %d\n", valor, fatorial(valor));

}
*/


/*  Tipo abstrato de dados - TAD aula 228

    Um conjunto de dados e tambÃ©m de operaÃ§Ã£oes para manupular esses dados

    exemplo de conjunto de dado

    typedef struct{
        No *topo;
        int tam;
    }Pilha;

    exemplo de operaÃ§Ã£o

    voi criar_pilha(Pilha *p)


*/

/*
            Aula 227: Estrutura de dados PILHA: Segunda versÃ£o




typedef struct{
    int dia, mes, ano;
}Data;

typedef struct{
    char nome[50];
    Data data;
}Pessoa;

typedef struct no{
    Pessoa p;
    struct no *proximo;
}No;

typedef struct{
    No *topo;
    int tam;
}Pilha;

Pessoa ler_pessoa(){
    Pessoa p;
    printf("\nDigite nome e data de nascimento dd mm aaaa:\n");
    scanf("%49[^\n]%d%d%d", p.nome, &p.data.dia, &p.data.mes, &p.data.ano);
    return p;
}

void imprimir_pessoa(Pessoa p){
    printf("\nNome: %s\nData: %2d/%2d/%4d\n", p.nome, p.data.dia, p.data.mes, p.data.ano);
}

void criar_pilha(Pilha *p){
    p->topo = NULL;
    p->tam = 0;
}

void empilhar(Pilha *p){
    No *novo = malloc(sizeof(No));

    if(novo){
        novo->p = ler_pessoa();
        novo->proximo = p->topo;
        p->topo = novo;
        p->tam++;
    }
    else
        printf("\nErro ao alocar memoria...\n");
}

No* desempilhar(Pilha *p){
    if(p->topo){
        No *remover = p->topo;
        p->topo = remover->proximo;
        p->tam--;
        return remover;
    }
    else
        printf("\nPilha vazia!\n");
    return NULL;
}

void imprimir_pilha(Pilha *p){
    No *aux = p->topo;
    printf("\n----------- PILHA Tam: %d --------------\n", p->tam);
    while(aux){
        imprimir_pessoa(aux->p);
        aux = aux->proximo;
    }
    printf("\n--------- FIM PILHA ------------\n");
}

int main(){

    No *remover;
    Pilha p;
    int opcao;

    criar_pilha(&p);

    do{
        printf("\n0 - Sair\n1 - Empilhar\n2 - Desempilhar\n3 - Imprimir\n");
        scanf("%d", &opcao);
        getchar();

        switch(opcao){
        case 1:
            empilhar(&p);
            break;
        case 2:
            remover = desempilhar(&p);
            if(remover){
                printf("\nElemento removido com sucesso!\n");
                imprimir_pessoa(remover->p);

                free(remover);
            }
            else
                printf("\nSem no a remover.\n");
            break;
        case 3:
            imprimir_pilha(&p);
            break;
        default:
            if(opcao != 0)
                printf("\nOpcao invalida!!!\n");
        }
    }while(opcao != 0);

    return 0;
}

*/

/*
            Aula 224 atÃ© 226: Estruturas de dados dinÃ¢micas





typedef struct{
    int dia, mes, ano;
}Data;

typedef struct{
    char nome[50];
    Data data;
}Pessoa;

typedef struct no{
    Pessoa p;
    struct no *proximo;
}No;

Pessoa ler_pessoa(){
    Pessoa p;

    printf("\nDigite nome e data de nascimento dd mm aaaa:\n");
    scanf("%49[^\n]%d%d%d", p.nome, &p.data.dia, &p.data.mes, &p.data.ano);
    return p;
}

void imprimir_pessoa(Pessoa p){
    printf("\nNome: %s\nData: %2d/%2d/%4d\n", p.nome, p.data.dia, p.data.mes, p.data.ano);
}

// funÃ§Ã£o para a operaÃ§Ã£o push (empilhar)
No* empilhar(No *topo){
    No *novo = malloc(sizeof(No));

    if(novo){
        novo->p = ler_pessoa();
        novo->proximo = topo;
        return novo;
    }
    else
        printf("\nErro ao alocar memoria...\n");
    return NULL;
}

// funÃ§Ã£o para a operaÃ§Ã£o pop (desempilhar)
No* desempilhar(No **topo){
    if(*topo != NULL){
        No *remover = *topo;
        *topo = remover->proximo;
        return remover;
    }
    else
        printf("\nPilha vazia!\n");
    return NULL;
}

void imprimir_pilha(No *topo){
    printf("\n----------- PILHA --------------\n");
    while(topo){
        imprimir_pessoa(topo->p);
        topo = topo->proximo;
    }
    printf("\n--------- FIM PILHA ------------\n");
}

int main(){

    No *remover, *topo = NULL;
    int opcao;

    do{
        printf("\n0 - Sair\n1 - Empilar\n2 - Desempilhar\n3 - Imprimir\n");
        scanf("%d", &opcao);
        getchar();

        switch(opcao){
        case 1:
            topo = empilhar(topo);
            break;
        case 2:
            remover = desempilhar(&topo);
            if(remover){
                printf("\nElemento removido com sucesso!\n");
                imprimir_pessoa(remover->p);

                free(remover);
            }
            else
                printf("\nSem no a remover.\n");
            break;
        case 3:
            imprimir_pilha(topo);
            break;
        default:
            if(opcao != 0)
                printf("\nOpcao invalida!!!\n");
        }
    }while(opcao != 0);

    return 0;
}

*/


/*
explicaÃ§Ã£o o do porque do apelido na struct no e porque do tydef


Ã simples. A compilaÃ§Ã£o do nosso cÃ³digo C Ã© feita de cima para baixo da esquerda para a direita, igual Ã  leitura de um livro. Assim, no exemplo que vocÃª deu:
1 -  typedef struct {
2 -     Pessoa p;
3 -     No *proximo;
4 - } No;
Quando o compilador chegar na linha 3 ele ainda nÃ£o sabe quem Ã© No para criar o ponteiro, ao passo que ao fazer:
1 -  typedef struct no {
2 -     Pessoa p;
3 -     struct no *proximo;
4 - } No;
Quando chegar na linha 3 ele jÃ¡ sabe quem Ã© struct no' entÃ£o ele consegue criar o ponteiro corretamente.
Um ponto interessante que nÃ£o sei se vocÃª percebeu Ã© que esta forma de criar uma estrutura Ã© a junÃ§Ã£o de duas aÃ§Ãµes:
1Âº - a criaÃ§Ã£o da estrutura;
2Âº - dar um nome Ã  estrutura.

A criaÃ§Ã£o da estrutura Ã© assim:
1 -  struct no{
2 -     Pessoa p;
3 -     struct no *proximo;
4 - };
Apenas isso Ã© suficiente para criar uma estrutura que representa um nÃ³. PorÃ©m, toda vez que formos criar um nÃ³ precisamos digitar o nome completo, ou seja, 'struct no'. Acho isso muito longo rsrsrs. EntÃ£o podemos renomear nossa estrutura. Ã aqui que entra o typedef. A Ãºnica funÃ§Ã£o do typedef Ã© para renomear estruturas, assim:
typedef struct no No;
Na linha anterior eu estou dizendo que a partir de agora a minha estrutura 'struct no' se chama 'No'.
NÃ£o precisamos fazer isso em dois passos como mostrei, podemos fazer tudo de uma vez, criando a estrutura e jÃ¡ dando a ela um nome, como eu fiz na aula, assim:
1 -  typedef struct no {
2 -     Pessoa p;
3 -     struct no *proximo;
4 - } No;







*/

